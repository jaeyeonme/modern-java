## 스트림으로 데이터 수집

- Collectors 클래스로 컬렉션 만들고 사용하기
- 하나의 값으로 데이터 스트림 리듀스하기
- 특별한 리듀싱 요약 연산
- 데이터 그룹화와 분할
- 자신만의 커스텀 컬렉터 개발

> 컬렉션(Collection), 컬렉터(Collector), collect는 서로 다르다

자바8의 스트림은 데이터 집합을 멋지게 처리하는 게으른 반복자라고 설명할 수 있다. 스트림의 연산은 filter 또는 map 같은 중간 연산과 count, findFirst, forEach, reduce 등의 최종 연산으로서, 여러 연산을 연결할 수 있다.

중간 연산은 한 스트림을 다른 스트림으로 변환하는 연산으로서, 여러 연산을 연결할 수 있다. 중간 연산은 스트림 파이프라인을 구성하며, 스트림의 요소를 `소비` 하지 않는다. 반면 최종 연산은 스트림의 요소르 소비해서 최종 결과를 도출한다.

<br />

collect와 컬렉터로 구현할 수 있는 질의 예제

- 통화별로 트랜잭션을 그룹화한 다음에 해당 통화로 일어난 모든 트랜잭션 합계를 계산하시오.(Map<Currency, INteger> 반환)
- 트랜잭션을 비싼 트랜잭션과 저렴한 트랜잭션 두 그룹으로 분로하시오. (Map<Boolean, List<Transaction>> 반환)
- 트랜잭션을 도시 등 다수준으로 그룹화하시오. 그리고 각 트랜잭션이 비싼지 저렴한지 구분하시오. (Map<String, Map<Boolean, List<Transaction>>> 반환)
  
<br />
<br />

**통화별로 트랜잭션을 그룹화한 코드(명령형 버전)**
  
```java
Map<Currency, List<Transaction>> transactionByCurrencies = new HashMap<>(); // 그룹화한 트랜잭션을 저장할 맵을 생성한다.
for (Tranasaction transaction : transactions) { // 트랜잭션 리스트를 반복한다.
    Currency currency = transaction.getCurrency();
    List<Transaction> transactionsForCurrency = 
            transactionsByCurrencies.get(currency);
    if (transactionsForCurrency == null) {      // 현재 통화를 그룹화한 맵에 항목이 없으면 항목을 만든다.
        transactionsForCurrency = new ArrayList<>();
        transactionsByCurrencies.put(currency, transactionsForCurrency);
    }
    transactionsForCurrency.add(transaction);   // 같은 통화를 가진 트랜잭션 리스트에서 현재 탐색 중인 트랜잭션을 추가한다.
}
```

<br />

경험이 많은 자바 개발자라면 위와 같은 코드에 익숙할 것이다. 하지만 간단한 작업임에도 코드가 너무 길다는 사실은 부정하기 어렵다.
  
```java
Map<Currency, List<Transaction>> transactionsByCurrencies = 
    transactions.stream().collect(groupingBy(Transaction::getCurrency));
```
  
<br />
<br />
<br />
<br />
  
## 1. 컬렉터란 무엇인가?
함수형 프로그래밍에서는 '무엇'을 원하는지 직접 명시할 수 있어서 어떤 방법으로 이를 얻을지는 신경 쓸 필요는 없다. 이전 예제에서 collect 메서드로 Collector 인터페이스 구현을 전달했다. Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다.
  
<br />
<br />
<br />
  
### 1) 고급 리듀싱 기능을 수행하는 컬렉터
훌륭하게 설계된 함수형 API의 또 다른 장점으로 높은 수준의 조합성과 재사용성을 꼽을 수 있다. collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 컬렉터의 최대 강점이다. 스트림에 collect를 호출하면 스트림의 요소에 `리듀싱 연산` 이 수행된다.
  
<br />
  
보통 함수를 요소로 변환(toList처럼 데이터 자체를 변환하는 것보다는 데이터 저장 구조를 변환할 때가 많다)할 때는 컬렉터를 적용하며 최종 결과를 저장하는 자료구조에 값을 누적한다.
  
<br />
  
**통화별로 트랜잭션을 그룹화하는 리듀싱 연산**
![image](https://github.com/JaeYeon33/modern-java/blob/main/pictures/picture5.png?raw=true)

  
<br />
  
Collector 인터페이스의 메서드를 어떻게 구현하느냐에 따라 스트림에 어떤 리듀싱 연산을 수행할지 결정된다.

Collectors 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 팩토리 메서드를 제공한다. 가장 많이 사용하는 직관적인 정적 메서드로 `toList` 를 꼽을 수 있다.
  
```java
List<Transaction> transactions = 
    transactionStream.collect(Collectors.toList());
```
  
<br />
<br />
<br />
  
### 2) 미리 정의된 컬렉터
Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.
- 스트림 요소를 하나의 값으로 리듀스하고 요약
- 요소 그룹화
- 요소 분할

<br />
<br />
<br />
<br />

## 2. 리듀싱과 요약
컬렉터로 스트림의 항목을 컬렉션으로 재구성할 수 있다. 좀 더 일반적으로 말해 컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있다. 트리를 구성하는 다수준 맵, 메뉴의 칼로리 합계를 가리키는 단순한 정수 등 다양한 형식으로 결과가 도출될 수 있다.

<br />
  
첫 번째로 `counting()` 이라는 팩토리 메서드가 반환하는 컬렉터로 메뉴에서 요리 수를 계산한다.
  
```java
long howManyDishes = menu.stream().collect(Collectors.counting());
```

<br />
  
다음처럼 불필요한 과정을 생략할 수 있다.

```java
long howManyDishes = menu.stream().count();
```
  
<br />
  
지금부터는 Collectors 클래스의 정적 팩토리 메서드를 모두 임포트했다고 가정한다.
  
```java
import static java.util.stream.Collectors.*;
```
  
<br />
<br />
<br />
  
### 1) 스트림값에서 최대값과 최소값 검색
메뉴에서 칼로리가 가장 높은 요리를 찾는다고 가정하자. `Collectors.maxBy` , `Collectors.minBy` 두 개 의 메서드를 이용해서 스트림의 최대값과 최소값을 계산할 수 있다.  두 컬렉터는 스트림의 요소를 비교하는 데 사용할 Comparator를 인수로 받는다. 다음은 칼로리로 요리를 비교하는 Comparator를 구현한 다음에 `Collectors.maxBy` 로 전달하는 코드다.
  
```java
Comparator<Dish> dishCaloriesCOmparator =
    Comparator.comparingInt(Dish::getCalories);
```
  
```java
Opional<Dish> mostCalorieDish = 
    menu.stream()
        .collect(maxBy(dishCaloriesComparator);
```
  
<br />

자바8은 값을 포함하거나 또는 포함하지 않을 수 있는 컨테이너 `Opional` 을 제공한다. 또한 스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱 기능이 자주 사용된다. 이러한 연산은 `요약 연산(summarization)` 이라고 부른다.
  
<br />
<br />
<br />
  
### 2) 요약 연산
Collectors 클래스는 `Collectors.summingInt` 라는 특별한 요약 팩토리 메서드를 제공한다.

summingInt는 객체를 int로 매핑하는 함수를 인수로 받는다. summingInt의 인수로 전달된 함수는 객체를 int로 매핑한 컬렉터를 반환한다. 그리고 summingInt가 collect 메서드로 전달되면 요약 작업을 수행한다.
  
```java
int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
```
  
<br />
<br />
  
**summingInt 컬렉터의 누적 과정**
![image2](https://github.com/JaeYeon33/modern-java/blob/main/pictures/picture6.png?raw=true)
  
<br />
  
`Collectors.summingLong` 과 `Collectors.summingDouble` 메서드는 같은 방식으로 동작하며 각각 long 또는 double 형식의 데이터로 요약한다는 점만 다르다.

이러한 단순 합계 외에 평균값 계산 등의 연산도 요약 기느응로 제공된다.

`Collectors.averagingInt` , `averagingDouble` 등으로 다양한 형식으로 이루어진 숫자 집합의 평균을 계산할 수 있다.
  
```java
double avgCalories =
    menu.stream().collect(averagingInt(Dish::getCalories));
```
  
<br />
<br />
  
종종 이들 중 두 개 이상의 연산을 한 번에 수행해야 할 때도 있다. 이런 상황에서는 팩토리 메서드 `summarizingInt` 가 반환하는 컬렉터를 사용할 수 있다.

다음은 하나의 요약 연산으로 메뉴에 있는 요소 수, 요리의 칼로리 합계, 평균, 최대값, 최소값 등을 계산하는 코드다.
  
```java
IntSummaryStatistics menuStatistics = 
    menu.stream().collect(summarizingInt(Dish::getCalories));
```
  
<br />
  
위 코드를 실행하면 IntSummaryStatistics 클래스로 모든 정보가 수집된다. menuStatistics 객체를 출력하면 다음과 같은 정보를 확인할 수 있다.
  
```java
IntSummaryStatistics{count=9, sum=4300, min=120,
                      average=477.777778, max=800} 
```
  
<br />
  
마찬가지로 int뿐 아니라 long이나 double에 대응하는 summarizingLong, summarizingDouble 메서드와 관련된 `LongSummaryStatistics` , `DoubleSummaryStatistics` 클래스로 있다.
  
